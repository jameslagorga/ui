<!DOCTYPE html>
<html>
<head>
    <title>QA Queue</title>
    <style>
        body { font-family: sans-serif; margin: 2em; background-color: #f8f9fa; color: #212529; }
        h1 { text-align: center; color: #343a40; }
        #qa-queue { list-style-type: none; padding: 0; }
        .qa-item { background-color: #fff; border: 1px solid #dee2e6; border-radius: .25rem; margin-bottom: 1em; padding: 1em; }
        .qa-item h3 { margin-top: 0; }
        .preview-images { display: flex; gap: 10px; margin-top: 1em; margin-bottom: 1em; }
        .preview-images img { max-width: 200px; border: 1px solid #ccc; }
        .actions button { padding: .5em 1em; border: none; border-radius: .25rem; cursor: pointer; }
        .approve-btn { background-color: #28a745; color: white; }
        .reject-btn { background-color: #dc3545; color: white; }
        .block-btn { background-color: #fd7e14; color: white; }
        #loading { text-align: center; font-size: 1.2em; }
    </style>
</head>
<body>
    <h1>Recording QA Queue</h1>
    <div id="loading">Loading queue...</div>
    <ul id="qa-queue"></ul>

    <script>
        const queueList = document.getElementById('qa-queue');
        const loadingIndicator = document.getElementById('loading');

        async function fetchQueue() {
            try {
                const response = await fetch('/api/qa/queue');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const queue = await response.json();
                loadingIndicator.style.display = 'none';
                renderQueue(queue);
            } catch (error) {
                console.error('Error fetching QA queue:', error);
                queueList.innerHTML = '<li>Could not load QA queue.</li>';
            }
        }

        async function renderQueue(queue) {
            queueList.innerHTML = '';
            if (queue.length === 0) {
                queueList.innerHTML = '<li>The queue is empty!</li>';
                return;
            }

            for (const path of queue) {
                const listItem = document.createElement('li');
                listItem.className = 'qa-item';
                listItem.dataset.path = path;

                const parts = path.split('/');
                const podName = parts[parts.length - 1];
                const streamName = parts[parts.length - 2];

                let content = `<h3>${streamName} / ${podName}</h3>`;
                content += `<p><code>${path}</code></p>`;
                content += `<div class="preview-images" id="preview-${streamName}-${podName}">Loading previews...</div>`;
                content += `<div class="actions">
                    <button class="approve-btn" onclick="handleAction('approve', '${path}')">Approve</button>
                    <button class="reject-btn" onclick="handleAction('reject', '${path}')">Reject</button>
                    <button class="block-btn" onclick="handleBlock('${streamName}')">Block</button>
                </div>`;
                listItem.innerHTML = content;
                queueList.appendChild(listItem);

                fetchPreviews(streamName, podName);
            }
        }

        async function fetchPreviews(streamName, podName) {
            const previewContainer = document.getElementById(`preview-${streamName}-${podName}`);
            try {
                const response = await fetch(`/api/qa/previews/${streamName}/${podName}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const images = await response.json();
                
                if (images.length > 0) {
                    previewContainer.innerHTML = images.map(img => `<a href="${img}" target="_blank"><img src="${img}" alt="preview"></a>`).join('');
                } else {
                    previewContainer.textContent = 'No preview images available.';
                }
            } catch (error) {
                console.error(`Error fetching previews for ${streamName}/${podName}:`, error);
                previewContainer.textContent = 'Could not load previews.';
            }
        }

        async function handleAction(action, path) {
            const listItem = document.querySelector(`[data-path="${path}"]`);
            listItem.style.opacity = '0.5';

            try {
                const response = await fetch(`/api/qa/${action}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.details || `Failed to ${action}`);
                }
                
                listItem.remove();
                const remainingItems = queueList.getElementsByTagName('li');
                if (remainingItems.length === 0 || (remainingItems.length === 1 && remainingItems[0].textContent.includes('empty'))) {
                    queueList.innerHTML = '<li>The queue is empty!</li>';
                }

            } catch (error) {
                console.error(`Error during ${action}:`, error);
                alert(`An error occurred: ${error.message}`);
                listItem.style.opacity = '1';
            }
        }

        async function handleBlock(streamName) {
            try {
                const response = await fetch(`/api/qa/block`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stream_name: streamName })
                });

                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.details || `Failed to block stream`);
                }
                
                alert(`Stream '${streamName}' has been blocked for 1 hour.`);

                // After blocking, fetch the queue again and reject all segments for this stream
                const queueResponse = await fetch('/api/qa/queue');
                if (!queueResponse.ok) throw new Error(`HTTP error! status: ${queueResponse.status}`);
                const currentQueue = await queueResponse.json();

                const segmentsToReject = currentQueue.filter(path => {
                    const parts = path.split('/');
                    const segmentStreamName = parts[parts.length - 2];
                    return segmentStreamName === streamName;
                });

                for (const path of segmentsToReject) {
                    console.log(`Auto-rejecting segment ${path} for blocked stream ${streamName}`);
                    await handleAction('reject', path);
                }
                // Re-render the queue to reflect the rejections
                fetchQueue();

            } catch (error) {
                console.error(`Error during block:`, error);
                alert(`An error occurred: ${error.message}`);
            }
        }

        fetchQueue();
    </script>
</body>
</html>
